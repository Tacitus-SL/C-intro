# C / Linux: Шпаргалка
## Оглавление
- [Введение](#введение)
  - [Препроцессор](#что-такое-препроцессор)
  - [Макрос?](#что-такое-макрос)
  - [Как код на C превращается в программу](#как-код-на-с-превращается-в-программу)
- [1. Препроцессор: `#include` и `#define`](#1-препроцессор-include-и-define)
  - [`#include`](#include)
  - [`#define`](#define)
- [2. Типы данных и модификаторы](#2-типы-данных-и-модификаторы)
  - [`typedef`](#typedef)
- [3. Указатели и разыменование](#3-указатели-и-разыменование)
- [4. Структуры и указатели на них](#4-структуры-и-указатели-на-них)
- [5. Динамическая память](#5-динамическая-память-malloc-calloc-realloc-free)
  - [malloc()](#51-malloc)
  - [calloc()](#52-calloc)
  - [relloc()](#53-relloc)
  - [free()](#54-free)
- [6. Zombie и Daemon процессы](#6-zombie-и-daemon-процессы)
  - [Zombie процесс](#62-zombie)
  - [Daemon процесс](#63-daemon)
- [7. Сигналы](#7-сигналы)
- [8. Многопоточность и синхронизация](#8-многопоточность-и-синхронизация)
  - [Mutex](#82-mutex)
  - [Semaphore](#83-semaphore)
  - [Condition Variable](#84-condition-vatiable)
  - [Barrier](#85-barrier)
  - [Atomic operations](#86-atomic-operations)
- [9. IPC (межпроцессное взаимодействие)](#9-ipc-межпроцессное-взаимодействие)
  - [Pipes](91-pipes)
  - [FIFOs](#92-named-pipes-fifos)
  - [Message Queues](93-message-queues-posix)
  - [Shared Memory](94-shared-memory)
  - [Semaphores v.2](95-semaphores)
  - [Signals v.2](96-signals)
  - [Unix Domain Sockets](97-unix-domain-sockets)
  - [Сравнительная таблица](99-сравнительная-таблица)
- [10. IO Multiplexing](#10-io-multiplexing)
  - [select()](101-select)
  - [poll()](102-poll)
  - [epoll()](103-epoll)
- [11. Статические и динамические библиотеки](#11-статические-и-динамические-библиотеки)
  - [Статическая библиотека](#111-статическая-библиотека)
  - [Динамическая библиотека](#112-динамическая-библиотека)
- [12. Сетевое программирование: UDP, TCP и Сокеты](#12-сетевое-программирование-udp-tcp-и-сокеты)
  - [UDP](#123-udp-user-datagram-protocol)
  - [TCP](#124-tcp-transmission-control-protocol)
  - [Сокеты](#126-сокеты)
- [13. Makefile](#13-makefile-продвинутый-уровень)
  - [Типы переменных](#131-типы-переменных)
  - [Специальные переменные](#132-спецальные-переменные)
  - [Автоматическое перечисление файлов](#133-автоматическое-перечисление-файлов)
  - [Финальный продвинутый Makefile!](#134-финальный-продвинутый-Makefile)
  - [Include Guards](#135-include-guards)
  
## 0. Введение

Программирование на языке C начинается не только с понимания синтаксиса, но и с осознания того, как работает компиляция.  
Перед тем как компилятор начнёт анализировать код, его обрабатывает **препроцессор** — специальный этап, отвечающий за подготовку исходного текста программы.

### Что такое препроцессор?

Препроцессор — это инструмент, который выполняет обработку кода *до* компиляции.  
Он занимается:

- подключением файлов (`#include`)
- созданием текстовых подстановок (`#define`)
- условной компиляцией (`#ifdef`, `#ifndef`, `#if`)
- разворачиванием макросов
- удалением комментариев

Работа препроцессора не знает о типах данных — он просто преобразует текст программы.

### Что такое макрос?

**Макрос** — это правило, по которому препроцессор выполняет текстовую замену в коде.  
Можно считать макросы "шаблонами" или "ярлыками", которые подставляются в программу до компиляции.

Основные виды макросов:

- **Макрос-константа**  
  ```c
  #define PI 3.14
  ```
- **Условные макросы для включения/исключения кода**
  ```c
  #ifdef DEBUG
  printf("Debug mode\n");
  #endif
  ```

Макросы удобны, но могут быть опасны из-за отсутствия проверки типов и возможных ошибок подстановки, поэтому в современном коде их используют осторожно.

### Как код на С превращается в программу
Когда ты пишешь `program.c`, он не превращается в бинарник сразу.
Компилятор проходит 4 основных этапа:

#### 0.1 **Препроцессор**
   
Выполняется первым.
Он:
   -  подставляет #include
   -  разворачивает #define
   -  обрабатывает #ifdef, #if, #pragma
   -  удаляет комментарии
   Команда:
   ```c
   gcc -E program.c -o program.i
   ```
   Результат: program.i — обычный текстовый файл с полностью развёрнутым кодом.
   
#### 0.2 **Компилятор**
   
Берёт результат препроцессора и превращает C-код в assembly (ассемблерный код).
Компилятор:
- анализирует синтаксис
- проверяет типы
- оптимизирует код
- генерирует ассемблер
Команда:
```c
gcc -S program.i -o program.s
```
Результат: program.s — ассемблерный код.

#### 0.3 **Ассемблер**

Превращает ассемблерный код в машинный код, но ещё не полный исполняемый файл.

Команда:
```c
gcc -c program.s -o program.o
```
Результат: program.o — объектный файл (часть будущей программы).
Это бинарный файл, который содержат:
- машинный код
- таблицы символов
- незаполненные ссылки на функции (например, `printf`)

#### 0.3.5 **Дополнительно: создание других объектных файлов**

Если проект большой:
- компилятор генерирует много `.o` файлов
- некоторые из них сгруппированы в `.a` (static libraries)
- или `.so` (shared libraries)
  
#### 0.4 **Линковщик**

Собирает все объектные файлы (*.o) + стандартные библиотеки (например, libc)
в единый исполняемый файл.

Линкер:
- связывает вызовы функций (например, где лежит printf)
- объединяет все объектные файлы
- собирает таблицы адресов и секции памяти
- проверяет повторные определения символов

Команда:
```c
gcc program.o -o program
```
Результат: готовый бинарник → program

#### 0.4.5 Загрузчик

Когда ты вызываешь программу:
```c
./program
```

Срабатывает динамический загрузчик, который:
- мапит бинарник в память
- мапит libc.so, libpthread.so, и др.
- фиксирует PLT/GOT таблицы
- подготавливает стек (!)
- вызывает конструкторы (.init_array)
- вызывает main()


#### 0.5 Выполнение
   Операционная система:
   - Создаёт процесс
   - Выделяет память
   - настраивает argc/argv
   - подготавливает окружение (environment variables)
   - передаёт управление загрузчику
   - Загрузчик вызывает main()

#### 0.6 Полный путь, как C-код превращается в программу

```text
file.c
  ↓ (Препроцессор — разворачивает include/define)
file.i
  ↓ (Компилятор — анализирует, оптимизирует, создаёт assembly)
file.s
  ↓ (Ассемблер — превращает в машинный код)
file.o
  ↓ (Линковка — объединяет объектные файлы, подставляет адреса)
program (ELF)
  ↓ (Динамический загрузчик — подгружает библиотеки, готовит окружение)
main()
```

---

## 1. Препроцессор: `#include` и `#define`

### `#include` 
Вставляет содержимое другого файла **до компиляции**.

### Два способа:

#### `<file>` — ищет файл в системных директориях
```c
#include <stdio.h> // стандартная библиотека ввода/вывода
```

#### `"file"` — ищет сначала в текущей директории, потом в системной
```c
#include "myheader.h"
```

---

### `#define`

Создаёт макрос (текстовую подстановку).

#### Пример константы
```c
#define PI 3.14159
```

#### Пример функции-макроса
```c
#define SQUARE(x) ((x) * (x))
```

#### Разница с `const`
- `#define` — чистая текстовая подстановка, нет проверки типов.
- `const` — настоящая переменная:

```c
const double pi = 3.14159;
```

---

| Что                      | `#define`                               | `const`              |
|--------------------------|----------------------------------------|---------------------|
| Обрабатывается           | препроцессором                          | компилятором        |
| Тип                      | отсутствует (текстовая подстановка)     | есть строгий тип    |
| Видимость в отладке      | нет                                     | есть                |
| Для чего используется    | макросы, константы, условная компиляция| неизменяемые переменные |
| Проверка типов           | нет                                     | есть                |
| Память                   | не занимает (подстановка в код)         | может занимать (если переменная) |
| Можно использовать в...  | `#if`, `#ifdef`, `#ifndef`             | нельзя              |
| Область применения       | любой фрагмент текста                   | переменные или параметры |
| Модифицирует поведение   | да (замена текста)                      | нет — обычная переменная |
| Лучше всего подходит для | макросов, флагов, встроенных выражений | констант со строгой типизацией |


---

Часто импортируемые библиотеки в заданиях:
```c
#include <stdio.h>      // стандартный ввод/вывод: printf, scanf, fprintf, fopen
#include <stdlib.h>     // общие утилиты: malloc, calloc, realloc, free, exit, atoi
#include <string.h>     // работа со строками: strcpy, strcat, strlen, strcmp, memset
#include <unistd.h>     // POSIX API: fork, exec, pipe, read, write, close, sleep, getpid
#include <errno.h>      // для работы с кодами ошибок errno
#include <fcntl.h>      // управление файлами и дескрипторами: open, O_RDONLY, O_CREAT
#include <sys/types.h>  // основные типы данных: pid_t, size_t, key_t
#include <sys/stat.h>   // структура stat, режимы файлов, mkdir
#include <time.h>       // работа с временем: time, clock, nanosleep
#include <signal.h>     // работа с сигналами: sigaction, signal, raise, kill
#include <pthread.h>    // POSIX потоки: pthread_create, pthread_mutex, pthread_cond, pthread_barrier
#include <semaphore.h>  // семафоры: sem_init, sem_wait, sem_post, sem_destroy
#include <stdatomic.h>  // атомарные операции: atomic_int, atomic_fetch_add
#include <sys/wait.h>   // работа с процессами: wait, waitpid, WNOHANG
#include <sys/mman.h>   // shared memory: mmap, munmap, PROT_READ/WRITE, MAP_SHARED
#include <sys/ipc.h>    // IPC ключи: ftok, IPC_CREAT
#include <sys/msg.h>    // очереди сообщений: msgget, msgsnd, msgrcv
#include <sys/sem.h>    // системные семафоры (SysV): semget, semop
#include <sys/shm.h>    // системная shared memory: shmget, shmat, shmdt
#include <sys/socket.h> // сокеты: socket, bind, listen, accept, connect
#include <netinet/in.h> // структуры для работы с IP (sockaddr_in)
#include <arpa/inet.h>  // преобразование IP адресов: inet_addr, inet_ntoa
#include <sys/select.h> // I/O Multiplexing: select, FD_SET, FD_ZERO
#include <sys/epoll.h>  // I/O Multiplexing (Linux): epoll_create, epoll_ctl, epoll_wait
#include <sys/syscall.h> // syscall для futex и других системных вызовов
```

---

## 2. Типы данных и модификаторы

### Базовые типы C

```c
int a = 10;
unsigned int b = 20;
long c = 1000000;
float f = 3.14;
double d = 2.71828;
char ch = 'A';
extern volatile int g_counter; //в хедере чаще всего
```

- `const` — переменная только для чтения.
- `volatile` — значение может меняться извне, компилятор не оптимизирует доступ.
- `unsigned char` — это целочисленный тип размера 1 байт, который может хранить только положительные значения.
- `extern` — это указание компилятору, что переменная или функция объявляется, но определяется в другом месте (в другом файле или позже в коде)

---

## `typedef`

`typedef` используется для создания нового имени (псевдонима) для существующего типа.  
Это не новый тип — просто удобное альтернативное название, улучшающее читаемость кода.

### Примеры использования

#### 2.1 Псевдоним для стандартного типа
```c
typedef unsigned long ulong;
```
Теперь можно писать так:
```c
ulong x = 100;
```

---

#### 2.2 Упрощение записи указателей
```c
typedef int* int_ptr;

int_ptr p;   // вместо: int *p;
```

---

#### 2.3 Типы для структур
Без typedef
```c
struct Point {
    int x, y;
};

struct Point p;  // нужно писать "struct" каждый раз
```
С typedef
```c
typedef struct {
    int x, y;
} Point;

Point p;    // короче и удобнее
```

---

## 3. Указатели и разыменование
Указатель — это переменная, которая хранит адрес другой области памяти (обычно адрес другой переменной).

- `*` — разыменование  
- `&` — получение адреса


```c
int x = 5;
int *p = &x;     // указатель на x
printf("%d\n", *p); // разыменование, вывод 5

int arr[3] = {1,2,3};
int *ptr = arr;  // имя массива — указатель на первый элемент
```

---

## 4. Структуры и указатели на них

```c
struct Point {
    int x, y;
};

struct Point p1 = {10, 20};
struct Point *pp = &p1;

printf("%d\n", pp->x); // 10
```
-> разыменовывает указатель на структуру и обращается к её полю в одном шаге.

---

## 5. Динамическая память: `malloc`, `calloc`, `realloc`, `free`
Динамическая память — это область памяти, которую программа запрашивает и освобождает вручную во время выполнения

---

### 5.1 `malloc`
Выделяет непрерывный блок памяти.

```c
int *arr = (int*)malloc(5 * sizeof(int));
```

Память **не инициализирована**.

---

### 5.2 `calloc`
Выделяет и **обнуляет** память.

```c
int *arr = (int*)calloc(5, sizeof(int));
```

---

### 5.3 `realloc`
Меняет размер существующего блока.

```c
arr = (int*)realloc(arr, 10 * sizeof(int));
```

---

### 5.4 `free`
Освобождает выделенную память.

```c
free(arr);
arr = NULL;
```

---

### Различия между `malloc`, `calloc`, `realloc`

| Функция | Инициализация | Аргументы | Назначение |
|--------|---------------|-----------|------------|
| malloc | нет | размер в байтах | выделяет память |
| calloc | да (0) | количество, размер одного | выделяет и обнуляет |
| realloc | сохраняет старые данные | указатель, новый размер | меняет размер блока |

---

## 6. Zombie и Daemon процессы
### 6.1 Создание процессов

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process\n");
        exit(0);
    } else {
        wait(NULL); // ждём дочерний процесс
        printf("Parent process\n");
    }
}
```
---

### 6.2 Zombie

Процесс завершён, но родитель не вызвал `wait()`, то есть все еще остается в системе, но в то же время не занимают CPU.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child done\n");
        exit(0);
    } else {
        sleep(10); // дочерний — zombie
    }
}
```

**Как избежать:** вызывать `wait()` / `waitpid()`.

---

### 6.3 Daemon

Фоновый процесс, не привязанный к терминалу и не имеющий родителя4.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid > 0) exit(0);
    setsid();
    while(1) {
        sleep(1);
    }
}
```
---

## 7. Сигналы
Сигнал — это уведомление ядра процессу.
Сигнал может:
- SIGKILL: прервать программу,
- SIGPIPE: завершить программу,
- SIGCHLD: ничего не сделать (если он игнорируется),
- SIGSTOP: остановить выполнения,
- SIGCONT: возобновить выполнение.
```c
#include <signal.h>
#include <stdio.h>

void handler(int sig) {          // Функция-обработчик сигнала
    printf("Caught %d\n", sig); // Выводим номер сигнала, который пришёл
}

int main() {
    struct sigaction sa;          // Создаём структуру, описывающую поведение сигнала

    sa.sa_handler = handler;      // Назначаем обработчик сигнала (нашу функцию handler)
    sigemptyset(&sa.sa_mask);     // Инициализируем маску сигналов — пока выполняется handler, другие сигналы не блокируются
    sa.sa_flags = 0;              // Флаги поведения сигнала (0 — базовое поведение без дополнительных опций)

    sigaction(SIGINT, &sa, NULL); // Привязываем структуру sa к сигналу SIGINT (Ctrl+C)
                                   // NULL — старое действие сигнала не сохраняем

    while(1);                     
}

```

---

## 8. Многопоточность и синхронизация
Поток — это отдельная последовательность выполнения внутри процесса, работающая параллельно с другими потоками и использующая общую память процесса.
---

### 8.1 Создание потока
```c
#include <pthread.h>
#include <stdio.h>

void* thread_func(void* arg) {
    printf("Hello from thread %d\n", *(int*)arg);
    return NULL;
}

int main() {
    pthread_t t;
    int id = 1;
    pthread_create(&t, NULL, thread_func, &id);
    pthread_join(t, NULL);
}
```

---

### 8.2 Mutex
Mutex — это механизм, который позволяет только одному потоку одновременно работать с ресурсом, предотвращая гонку данных.
```c
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);

pthread_mutex_lock(&lock);
// критическая секция
pthread_mutex_unlock(&lock);
```

---

### 8.3 Semaphore
Semaphore — это счётчик, который ограничивает одновременный доступ потоков или процессов к ресурсу

Имеет следующие cистемные вызовы:
- Неименнованые: `sem_init(sem_t *sem, int pshared, unsigned int value)`.(pshared = 0 → семафор используется между потоками одного процесса. pshared = 1 → семафор может использоваться между разными процессами, если хранится в общей памяти (shared memory).)
- Именованные: `sem_open("/mysem", ...)`
- `sem_wait(sem)` — ждёт, пока значение семафора больше 0, затем уменьшает его на 1.
- `sem_post(sem)` — увеличивает значение семафора на 1, пробуждая ожидающий процесс, если он есть.
- `sem_open(name, flags, mode, value)` — создаёт или открывает именованный семафор.
- `sem_close(sem)` — закрывает дескриптор семафора.
- `sem_trywait(sem)` — пробует уменьшить значение семафора на 1 без блокировки. (val > 0 → уменьшает и возвращает 0. val = 0 → сразу возвращает -1 с errno = EAGAIN.)
- `sem_getvalue(sem, int *sval)` — получает текущее значение семафора.
- `sem_destroy(sem)` — уничтожает неименованный семафор.
- `sem_unlink(name)` — удаляет именованный семафор из системы.

```c
#include <semaphore.h>
sem_t sem;
sem_init(&sem, 0, 3); // 3 ресурса

sem_wait(&sem); // захватываем
sem_post(&sem); // освобождаем

```

---

### 8.4 Condition Variable
Condition variable — это механизм, который позволяет потоку ждать определённого события и синхронизироваться с другими потоками через сигнал.
```c
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&mutex);
pthread_cond_wait(&cond, &mutex); // ждём события
pthread_mutex_unlock(&mutex);

pthread_cond_signal(&cond); // сигнал для пробуждения

```

---

### 8.5 Barrier
Barrier — это точка синхронизации, где несколько потоков ждут друг друга, прежде чем все смогут продолжить выполнение.
```c
pthread_barrier_t barrier;
pthread_barrier_init(&barrier, NULL, 3); // ждём 3 потока
pthread_barrier_wait(&barrier); // каждый поток ждёт остальных
```

---

### 8.6 Atomic operations
Atomic operation — это операция над переменной, которая выполняется полностью без прерываний, гарантируя корректный доступ в многопоточном окружении.
```c
#include <stdatomic.h>
atomic_int a = 0;
atomic_fetch_add(&a, 1);
```

---

### 8.7 Таблица
| Механизм             | Основная задача                  | Ограничения / Состояние             | Особенности использования |
|----------------------|---------------------------------|------------------------------------|--------------------------|
| Mutex                | Взаимное исключение, защита критической секции | Только один поток за раз           | Захватывает ресурс, другие ждут; подходит для защиты общих данных |
| Semaphore            | Ограничение количества потоков/ресурсов       | Счётчик ≥ 0                        | Позволяет N потокам одновременно работать с ресурсом; бинарный или счётный |
| Condition Variable   | Ждать наступления события                      | Не хранит состояния                | Используется с mutex; поток ждёт события, освобождая mutex пока ждёт |
| Barrier              | Синхронизация всех потоков на точке            | Ждёт указанное количество потоков  | Все потоки останавливаются на барьере, пока все не достигнут; потом продолжают работу |
| Atomic Operations    | Безопасная работа с простыми переменными      | Неразрывные операции               | Выполняются полностью без прерывания; подходят для lock-free счётчиков и флагов |

---

## 9. IPC (межпроцессное взаимодействие)
IPC — это механизм, с помощью которого два или более процесса могут обмениваться данными или сигналами.
В С/Unix-подобных системах есть несколько стандартных способов:

---

### 9.1 Pipes
Pipe — механизм передачи данных в виде потока байт между двумя связанными процессами (обычно родитель и потомок), поддерживает однонаправленное общение.

```c
#include <unistd.h>
int main() {
    int fd[2]; // fd[0] - чтение, fd[1] - запись
    pipe(fd);
    if (fork() == 0) {
        // Дочерний процесс - читает
        close(fd[1]);
        char buf[100];
        read(fd[0], buf, sizeof(buf));
        printf("Child received: %s\n", buf);
    } else {
        // Родительский процесс - пишет
        close(fd[0]);
        write(fd[1], "Hello from parent", 17);
    }
    return 0;
}
```
Особенности:
- Только родитель → ребёнок (однонаправленно).
- Pipe живёт только пока процессы существуют.
- Данные — поток байт.

---

### 9.2 Named Pipes (FIFOs)
Fifo — однонаправленный канал передачи данных между процессами, имеющий имя в файловой системе; позволяет обмениваться данными между процессами, которые не находятся в прямой родственной связи.

Систенмые вызовы:
- mkfifo — создать именованный pipe (FIFO)
```c
mkfifo("/tmp/my_fifo", 0666); //Любой процесс может открыть /tmp/my_fifo для чтения или записи
```

- open — открыть FIFO. Можно использовать O_RDONLY / O_WRONLY / O_RDWR
```c
int fd = open("/tmp/my_fifo", O_WRONLY);
```

- read / write — работа с pipe
```c
write(fd, buffer, size);
read(fd, buffer, size);
```

- close — закрыть дескриптор
```c
close(fd);
```
- unlink — удалить именованный pipe
```c
unlink("/tmp/my_fifo");
```

Код для примера:
```c
#include <sys/stat.h>   // mkfifo, S_IRUSR, S_IWUSR и др.
#include <fcntl.h>      // open, O_RDONLY, O_WRONLY и др.
#include <unistd.h>     // read, write, close
int main() {
    const char *fifo_name = "/tmp/my_fifo";  // Имя FIFO в файловой системе
    mkfifo(fifo_name, 0666); // Создаём именованный pipe (FIFO). 0666 — права доступа (чтение и запись для всех)
    int fd = open(fifo_name, O_WRONLY); // Открываем FIFO для записи. Блокируется, пока не откроется процесс на чтение
    write(fd, "Hello FIFO", 10); // Пишем данные в FIFO. Для чтения другой процесс должен открыть FIFO на чтение
    close(fd); // Закрываем дескриптор после записи
    unlink(fifo_name);
    return 0;
}

```
Особенности:
- Может существовать между любыми процессами.
- Однонаправленный.
- Нужно удалять через unlink(fifo_name).

---

### 9.3 Message Queues (POSIX)
Message Queue — структура данных, предоставляемая ОС, для обмена дискретными сообщениями между процессами; поддерживает приоритет сообщений и позволяет работать с несколькими отправителями и получателями одновременно.

```c
#include <mqueue.h>
int main() {
    mqd_t mq;
    struct mq_attr attr = {0, 10, 256, 0}; // max 10 msg, 256 bytes each
    mq = mq_open("/myqueue", O_CREAT | O_WRONLY, 0644, &attr);
    mq_send(mq, "Hello MQ", 8, 0);
    mq_close(mq);
    return 0;
}
```
Особенности:
- Позволяет передавать сообщения как объекты, а не поток байт.
- Сообщения могут иметь приоритет.
- Нужно удалять через mq_unlink("/myqueue").

---

### 9.4 Shared Memory

Shared Memory — область памяти, доступная сразу нескольким процессам; обеспечивает высокую скорость обмена данными, но требует внешних средств синхронизации (например, семафоров или мьютексов) для предотвращения состояния гонки.

Системные вызовы:
- shm_open — создать / открыть объект разделяемой памяти. Возвращает файловый дескриптор.
```c
int fd = shm_open("/name", O_CREAT | O_RDWR, 0666);
```
- ftruncate — задать фактический размер shared memory.
```c
ftruncate(fd, size);
```
- mmap — отобразить область памяти. Возвращает указатель, через который можно читать и писать.
```c
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_SHARED, fd, 0);
```
- Использовать память. Любые операции с памятью: структуры, массивы, произвольные данные.
```c
strcpy(ptr, "Hello");
```
- munmap — убрать отображение. Процесс больше не использует эту память (но объект всё ещё существует).
```c
munmap(ptr, size);
```
- close — закрыть файловый дескриптор. Закрывает FD от shm_open.
```c
close(fd);
```
- shm_unlink — удалить объект. После этого другие процессы не смогут его открыть.
```c
shm_unlink("/name");
```

Пример кода:
```c
#include <sys/mman.h>   // mmap, munmap, PROT_*, MAP_*
#include <fcntl.h>      // shm_open, O_CREAT, O_RDWR
#include <unistd.h>     // ftruncate, close
#include <string.h>     // strcpy
int main() {
    const char *name = "/my_shm";     // Имя объекта shared memory (обязательно начинается с '/')

    // Создаём или открываем сегмент разделяемой памяти.
    // O_CREAT — создать, если нет
    // O_RDWR  — открыть для чтения и записи
    // 0666    — права доступа
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);

    ftruncate(fd, 4096); // Устанавливаем размер сегмента (иначе будет 0 байт)

    // Отображаем объект в адресное пространство процесса:
    // NULL — система сама выберет адрес
    // 4096 — размер отображения
    // PROT_READ | PROT_WRITE — разрешено читать и писать
    // MAP_SHARED — изменения видны другим процессам
    // fd — файловый дескриптор shared memory
    // 0 — смещение
    char *ptr = mmap(NULL, 4096,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED,
                     fd, 0);
    strcpy(ptr, "Hello Shared Memory"); // Пишем строку прямо в shared memory
    munmap(ptr, 4096); // Удаляем отображение из памяти текущего процесса
    close(fd); // Закрываем файловый дескриптор
    shm_unlink(name); // Удаляем объект shared memory из системы
    return 0;
}

```

Особенности:
- Очень быстро.
- Требуется синхронизация, иначе данные могут портиться (например, с sem_t)

---

### 9.5 Semaphores

Semaphore — объект синхронизации, используемый для координации доступа нескольких процессов к общему ресурсу; может быть бинарным (mutex) или счётным. Не используется для передачи данных.

```c
#include <semaphore.h>
#include <fcntl.h>
int main() {
    sem_t *sem = sem_open("/mysem", O_CREAT, 0644, 1);
    sem_wait(sem);   // захват
    // критическая секция
    sem_post(sem);   // освобождение
    sem_close(sem);
    sem_unlink("/mysem");
    return 0;
}
```

Особенности:
- Только для синхронизации, данные не передаются.
- Часто используют вместе с shared memory.

---

### 9.6 Signals
Signal — асинхронные уведомления, отправляемые процессам для информирования о событиях, таких как завершение процесса, ошибки, таймеры или пользовательские события; сигналы передают только событие, а не данные.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
void handler(int sig) {
    printf("Received signal %d\n", sig);
}
int main() {
    signal(SIGUSR1, handler);
    printf("PID: %d\n", getpid());
    pause(); // ждем сигнала
    return 0;
}
```

Особенности:
- Асинхронно.
- Можно передавать только сигнал (не данные).

---

### 9.7 Unix Domain Sockets
Unix Domain Socket — механизм обмена данными между процессами на одном компьютере, обеспечивающий двунаправленную передачу байтов и возможность потоковой или сообщенийной коммуникации; по интерфейсу аналогичен TCP-сокетам, но работает локально.

```c
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, "/tmp/mysocket");
    bind(sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(sock, 5);
    int client = accept(sock, NULL, NULL);
    char buf[100];
    read(client, buf, sizeof(buf));
    printf("Received: %s\n", buf);
    close(client);
    close(sock);
    unlink("/tmp/mysocket");
    return 0;
}
```

Особенности:
- Можно использовать для межпроцессного и сетевого взаимодействия.
- Двунаправленные, универсальные.
- Более сложные, чем pipe/FIFO.

--- 

### 9.8 Общие рекомендации
- Для маленьких потоков байт → `pipe()` или `FIFO`.
- Для структурированных сообщений → `Message Queue`.
- Для больших объёмов данных и скорости → `Shared Memory + Semaphore`.
- Для универсальности и сетей → `Unix Domain Sockets`.
- Для уведомлений → `Signals`.

---

### 9.9 Сравнительная таблица
| Механизм IPC                  | Кратко                            | Плюсы                           | Минусы                                      |
|--------------------------------|----------------------------------|---------------------------------|--------------------------------------------|
| Pipes (именованные и неимен.)  | Поток байт между процессами       | Простой, потоковый              | Только однонаправленный (неименованные)   |
| FIFOs (Named Pipes)            | Pipe с именем в файловой системе | Межпроцессный, можно открывать в разное время | Однонаправленный                        |
| Message Queues                 | Очередь сообщений с приоритетом  | Двунаправленный, поддержка приоритета | Сложнее, ограничение на размер сообщений |
| Shared Memory                  | Общая память для процессов       | Очень быстро, можно передавать много данных | Требуется синхронизация (mutex/semaphore) |
| Semaphores                     | Счётчики для синхронизации       | Надёжная синхронизация          | Не передаёт данные                         |
| Signals                        | Асинхронные уведомления          | Лёгкие, быстрые                 | Только уведомление, нет данных             |
| Sockets (Unix Domain / TCP)    | Общение через сокеты             | Универсально, можно по сети     | Сложнее, накладные расходы                 |

---

## 10. I/O Multiplexing

I/O Multiplexing — это механизм, позволяющий одному процессу (или потоку) одновременно контролировать несколько файловых дескрипторов (сокетов, pipe, fifo, терминалов и т. д.) и эффективно ждать, пока хотя бы один из них станет готов к чтению/записи.

---

### 10.1 select()
- Старый и переносимый метод.
- Ограничение: FD_SETSIZE (~1024 дескриптора).
- Требует каждый раз заново заполнять fd_set.

Пример:
```c
#include <sys/select.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(0, &readfds); // stdin
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    int ret = select(1, &readfds, NULL, NULL, &timeout);
    if (ret > 0 && FD_ISSET(0, &readfds)) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
}
```

---

### 10.2 poll()
- Современная альтернатива select.
- Нет ограничения на количество FD.
- Структура pollfd для описания дескрипторов.
- O(n) по количеству дескрипторов.

Пример:
```c
#include <poll.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    struct pollfd fds[1];
    fds[0].fd = 0;           // stdin
    fds[0].events = POLLIN;

    int ret = poll(fds, 1, 5000); // 5000 ms
    if (ret > 0 && (fds[0].revents & POLLIN)) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
}
```

---

### 10.3 epoll (Linux only)
- Высокопроизводительный, событийно-ориентированный.
- Масштабируется на десятки тысяч дескрипторов.
- Используется в nginx, redis, node.js.

Пример:
```c
#include <sys/epoll.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    int epfd = epoll_create1(0);
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = 0; // stdin
    epoll_ctl(epfd, EPOLL_CTL_ADD, 0, &ev);

    struct epoll_event events[10];
    int n = epoll_wait(epfd, events, 10, 5000);
    if (n > 0) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
    close(epfd);
}
```

---

### 10.4 Сравнительная таблица
| Метод   | Ограничения            | Масштабируемость | Производительность | Особенности                                      |
|---------|-----------------------|-----------------|------------------|------------------------------------------------|
| select  | FD_SETSIZE (~1024)    | Низкая          | Средняя          | Требует каждый раз заполнять fd_set; совместим с Unix |
| poll    | Нет явных ограничений | Средняя         | Средняя          | Использует pollfd; O(n)                        |
| epoll   | Linux only            | Высокая         | Высокая          | Событийно-ориентированный; O(1) в большинстве случаев |

---

## 11. Статические и динамические библиотеки

Библиотеки — это набор объектных файлов (.o), которые содержат функции и переменные, готовые к использованию другими программами.
Главное отличие — способ подключения: на этапе компиляции (статическая) или на этапе выполнения (динамическая).

---

### 11.1 Статическая библиотека

Статическая библиотека (.a) — это архив объектных файлов, который встраивается в исполняемый файл на этапе линковки. После компиляции программа не требует файла библиотеки для запуска.

Создание статической библиотеки:
```
all: libfoo.a

libmath.a: foo.o
	ar rcs libmath.a foo.o  # создаём статическую библиотеку

math.o: math.c
	gcc -Wall -Wextra -std=c11 -c foo.c -o foo.o  # компилируем объектный файл

clean:
	rm -f libfoo.a *.o  
```

Использование в программе:
```c
#include "foo.h"

int main() {
    foo(); // функция из библиотеки
    return 0;
}
```

Компиляция с библиотекой:
```bash
all: main.c
	gcc -o main main.c -L. -Wl,-Bstatic -lmath -Wl,-Bdynamic

clean:
	rm -f main
```

Особенности:
- Все функции библиотеки включаются в бинарник.
- Программа полностью автономна.
- Бинарник может быть большим.
- Обновление библиотеки требует перекомпиляции программы.

---

### 11.2 Динамическая библиотека

Динамическая библиотека (`.so`) — это набор функций, подгружаемых во время выполнения программы.
Программа и библиотека связываются на этапе запуска или динамически через dlopen.

Создание динамической библиотеки:
```bash
libmath.so: foo.o
	gcc -shared -o libfoo.so foo.o

math.o: math.c
	gcc -Wall -Wextra -std=c11 -fPIC -c foo.c -o foo.o

main_dynamic: main.c libfoo.so
	gcc -o main_dynamic main.c -L. -lfoo
```
**Обязательный флаг:**
`-fPIC` — генерирует position-independent code (позволяет библиотеке загружаться в любое место в памяти), без абсолютных адресов.

Использование в программе:
```c
#include "foo.h"
int main() {
    foo(); // функция из библиотеки
    return 0;
}
```

Компиляция с динамической библиотекой:
```bash
gcc main.c -L. -lfoo -o program
export LD_LIBRARY_PATH=.  # если библиотека не в стандартном пути
./program
```

Особенности:
- Функции загружаются из внешнего файла при запуске.
- Меньший размер бинарника.
- Можно обновлять библиотеку без перекомпиляции программы.
- Нужно, чтобы .so была доступна в LD_LIBRARY_PATH или в стандартных директориях /usr/lib, /usr/local/lib.

---

### 11.3 Сравнение
| Параметр                     | Статическая библиотека (.a)           | Динамическая библиотека (.so)                           |
|-------------------------------|------------------------------------|--------------------------------------------------------|
| Когда подключается            | При компиляции/линковке            | Во время выполнения                                     |
| Размер бинарника              | Больше                             | Меньше                                                 |
| Обновление функций            | Только перекомпиляция               | Достаточно заменить .so                                |
| Автономность программы        | Полная                              | Требуется .so                                         |
| Скорость вызова               | Быстрее (нет дополнительных таблиц)| Слегка медленнее (PLT/GOT)                             |
| Поддержка нескольких программ | Каждая копия содержит функции       | Библиотека общая, экономия памяти                      |

---

## 12. Сетевое программирование: UDP, TCP и Сокеты

### 12.1 Базовые модели сети (OSI и TCP/IP)
**OSI (7 уровней)** — теоретическая модель: 
Physical → Data Link → Network → Transport → Session → Presentation → Application. 
Используется для понимания, но редко в реальной практике.

**TCP/IP (4 уровня)** — практическая модель, используемая в современных сетях:
- **Link (канальный уровень)** — железо и протоколы передачи (Ethernet, Wi-Fi), локальная доставка.
- **Internet (сетевой уровень)** — маршрутизация между сетями, IP-адреса.
- **Transport (транспортный уровень)** — передача данных между конечными точками (TCP, UDP).
- **Application (прикладной уровень)** — ваши программы и протоколы (HTTP, DNS).

В C-программах мы чаще работаем с транспортным и прикладным уровнем.

---

### 12.2 Как данные проходят от программы к сети
Программа -> сокет -> транспорт (UDP/TCP) -> IP маршрутизация -> Link -> физическая сеть
- Возврат пакета идёт по обратному пути.
- Мы будем разбирать UDP и TCP, их особенности и C API.

---

### 12.3 UDP (User Datagram Protocol)
- Без соединения, ориентирован на сообщения.
- Нет гарантии доставки, нет упорядочивания, нет управления перегрузкой.
- Сохраняет границы сообщений — одно sendto() = один датаграмм.
- Быстрый, низкая задержка, подходит для VoIP, DNS, стриминга, телеметрии.

**Структура UDP пакета:**
UDP-пакет помещается внутрь IP-пакета, который маршрутизируется через сеть.

**UDP API:**
```c
int fd = socket(AF_INET, SOCK_DGRAM, 0);       // создаем UDP-сокет
ssize_t sendto(fd, buf, len, flags, (struct sockaddr*)&dst, sizeof(dst)); // отправка
ssize_t recvfrom(fd, buf, sizeof(buf), flags, (struct sockaddr*)&src, &srclen); // прием
close(fd);                                     // закрытие
```

**Примеры:**
- UDP сервер — принимает данные и отправляет их обратно (echo server).
- UDP клиент — отправляет сообщение серверу и ждет ответа.
- Важно: IP и порт конвертируются в сетевой порядок байт (htons(), htonl()).

---

### 12.4 TCP (Transmission Control Protocol)
- Надёжный протокол, гарантирует доставку и порядок сообщений.
- Трёхстороннее рукопожатие при установлении соединения: `SYN -> SYN+ACK -> ACK`
- Требует соединения, поэтому используем `connect()` на клиенте и `accept()` на сервере.

**TCP API:**
```bash
int fd = socket(AF_INET, SOCK_STREAM, 0); # создаем TCP сокет

# Сервер
bind(fd, ...);
listen(fd, ...);
accept(fd, ...);

# Клиент
connect(fd, ...);

# Чтение/запись
send(fd, ...);
recv(fd, ...);

close(fd);  # or shutdown() for half-closes
```

**Отличие от UDP:** не нужно каждый раз указывать адрес для отправки (send() вместо sendto()).

**Состояния TCP:**
- TCP-сокет проходит через несколько состояний (LISTEN, ESTABLISHED, TIME_WAIT и т.д.).
- `listen()` подготавливает сокет к пассивному режиму (режиму ожидания входящих соединений).
- `accept()` создаёт отдельный сокет для каждого подключившегося клиента. Но блокирует сервер до подключения клиента.
- Для неблокирующих сокетов можно использовать `fcntl()`, `select()`, `poll()`, `epoll()`.

---

### 12.5 Инструменты для проверки сокетов в Linux
- **ss** — современный инструмент, показывает активные соединения:
```bash
ss -tuna        # все TCP/UDP соединения
ss -u -a        # только UDP
ss -t -l        # слушающие TCP
ss -tulpen      # с информацией о процессе

# Фильтровать по порту:
ss -t state LISTEN '( sport = :9001 )'
ss -u '( sport = :9000 )'

ss -ti # просмотр TCP‑таймеров и информации о контроле перегрузки.
```
- **Основные колонки ss:**
  - Netid — протокол (tcp/udp)
  - tate — состояние (LISTEN, ESTABLISHED, UNCONN)
  - Recv-Q / Send-Q — буферы ядра
  - Local/Peer Address:Port — локальный и удалённый адрес

- **Рецепты для отладки:**
```bash
# Кто слушает порт: 
ss -tlpen '( sport = :9001 )'

# Сервер слушает?
ss -tl | grep ':9001

# Проверка состояния TCP рукопожатия: 
ss -t state syn-sent,syn-recv

# UDP: проверка привязанных сокетов и очередей:
ss -uapn '( sport = :9000 )'
```
---

### 12.6 Сокеты
**Сокет** — это абстракция для точки обмена данными между программой и сетью.
Он связывает:
- Программу (процесс)
- Транспортный протокол (TCP/UDP)
- Сетевой адрес (IP + порт)

**Типы сокетов:**
| Тип          | Флаг в `socket()` | Описание                                      |
|-------------|-----------------|-----------------------------------------------|
| Потоковый    | `SOCK_STREAM`   | TCP, надёжная доставка, упорядоченный поток байтов |
| Датаграммный | `SOCK_DGRAM`    | UDP, «сообщения», ненадёжная доставка        |
| Сырой        | `SOCK_RAW`      | Для низкоуровневой работы с IP-пакетами (root-права) |


**Создание сокета:**
```c
#include <sys/types.h>
#include <sys/socket.h>

int fd = socket(AF_INET, SOCK_STREAM, 0); // TCP сокет
if (fd < 0) { perror("socket"); exit(1); }
```
- AF_INET — IPv4, AF_INET6 — IPv6, AF_UNIX — локальные UNIX сокеты
- SOCK_STREAM — TCP, SOCK_DGRAM — UDP
- Третий параметр обычно 0 (протокол выбирается автоматически)

**Привязка сокета к серверку (bind):**
На сервере:
```c
#include <netinet/in.h>

struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(9000);      // порт
addr.sin_addr.s_addr = INADDR_ANY; // любой локальный адрес

bind(fd, (struct sockaddr*)&addr, sizeof(addr));
```
После `bind()` сокет знает, на каком IP/порту слушать входящие соединения.

**Серверные сокеты TCP:**
- `listen()` — перевод сокета в пассивный режим, чтобы принимать соединения
- `accept()` — возвращает новый сокет для каждого клиента

```c
listen(fd, 5);                // очередь до 5 клиентов
int client_fd = accept(fd, NULL, NULL); // новый сокет для клиента
```

**Клиентские сокеты:**
```c
struct sockaddr_in srv;
srv.sin_family = AF_INET;
srv.sin_port = htons(9000);
inet_pton(AF_INET, "127.0.0.1", &srv.sin_addr);

connect(fd, (struct sockaddr*)&srv, sizeof(srv)); // подключение к серверу
```

**Отправка и прием данных:**
| Протокол | Отправка | Приём |
|----------|----------|-------|
| TCP      | `send(fd, buf, len, flags)` | `recv(fd, buf, len, flags)` |
| UDP      | `sendto(fd, buf, len, flags, (struct sockaddr*)&dst, sizeof(dst))` | `recvfrom(fd, buf, len, flags, (struct sockaddr*)&src, &srclen)` |

В TCP адрес указывать не нужно, потому что соединение уже установлено через connect()/accept().

**Закрытие сокета:**
```c
close(fd);        // полностью закрывает сокет
// или
shutdown(fd, SHUT_RDWR); // отключает передачу/приём частично
```

**Важные моменты:**
- Один сокет = один «канал» связи с конкретным клиентом (для TCP)
- Для UDP один сокет может отправлять/принимать сообщения от множества адресов
- Сокеты могут быть блокирующими или неблокирующими (fcntl, select, poll, epoll)
- В Linux для отладки используют ss (см. 12.6)

---
## 13. Makefile Продвинутый уровень
**Makefile** — это способ автоматизировать сборку проекта на C/C++ (и не только). На базовом уровне мы просто компилируем один или два файла, но на продвинутом уровне можно:
- Автоматизировать сборку сложных проектов.
- Управлять зависимостями.
- Использовать переменные и шаблоны.
- Создавать цели “phony” (не файлы).
- Делать инкрементальную сборку.

---

### 13.1 Типы переменных
- `=` — recursive (ленивое вычисление)
```bash
TAG = $(DATE)-debug # recursive (uses DATE on use-time)
```
- `:=` — simple (немедленное)
```bash
DATE := $(shell date +%s) # simple (expanded now)
```
- `?=` — установить, если пусто
- `+=` — добавить

---

### 13.2 Специальные переменные
**Prerequisite** — это файл, от которого зависит цель, и который должен существовать или быть обновлён раньше, чем цель.

**Основные автоматические переменные**
- `$@` — имя цели (target).
- `$<` — первый prerequisite (обычно используется в правилах, которые генерируют один файл из другого).
- `$^` — список всех prerequisites (удаляет дубликаты).
- `$?` — список prerequisites, которые новее, чем цель.
- `$*` — "stem" в шаблонных правилах (часть имени без суффикса).

**Компоненты директорий и файлов**
Для удобного получения пути или файла из автоматических переменных:
- `$(@D)` — директория, в которой находится цель.
- `$(@F)` — только имя файла цели.
- `$(<D)` — директория первого prerequisite.
- `$(<F)` — только имя файла первого prerequisite.
- 
---

### 13.3 Автоматическое перечисление файлов
```bash
SRC := $(wildcard src/*.c)
OBJ := $(SRC:src/%.c=build/%.o)

build/%.o: src/%.c
	$(CC) -Iinclude -c $< -o $@
```
---

### 13.4 Финальный продвинутый Makefile
```bash
SRC := $(wildcard src/*.c)
OBJ := $(SRC:src/%.c=build/%.o)

CC := gcc
CFLAGS := -Iinclude -Wall -Wextra -O2

# Папки
build/:
	mkdir -p build

deps/:
	mkdir -p deps

# Подключаем автоматически генерируемые .d
-include $(SRC:src/%.c=deps/%.d)

# Правило компиляции .c → .o + .d
build/%.o: src/%.c | deps/ build/
	$(CC) $(CFLAGS) -MMD -c $< -o $@ -MF deps/$*.d

# Финальная цель
app: $(OBJ)
	$(CC) $(OBJ) -o $@

clean:
	rm -rf build deps app
```
---

### 13.5 Include Guards
Без них при множественном включении файлов будет ошибка повторного определения. Использовать только в хедерах, в самом верху кода. 

**Пример:**
```bash
#ifndef JBX_MATH_VEC2_H
#define JBX_MATH_VEC2_H

typedef struct {
  int x, y;
} Vec2;

#endif
```

**OS-specific include guards**
```bash
#ifdef __linux__
// epoll
#elif __APPLE__
// kqueue
#else
#error "Unsupported OS"
#endif
```
