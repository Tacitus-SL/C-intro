# C / Linux: Шпаргалка
## Оглавление
- [Введение](#введение)
  - [Что такое препроцессор?](#что-такое-препроцессор)
  - [Что такое макрос?](#что-такое-макрос)
  - [Как код на C превращается в программу](#как-код-на-с-превращается-в-программу)
- [1. Препроцессор: `#include` и `#define`](#1-препроцессор-include-и-define)
  - [`#include`](#include)
  - [`#define`](#define)
- [2. Типы данных и модификаторы](#2-типы-данных-и-модификаторы)
  - [`typedef`](#typedef)
- [3. Указатели и разыменование](#3-указатели-и-разыменование)
- [4. Структуры и указатели на них](#4-структуры-и-указатели-на-них)
- [5. Динамическая память](#5-динамическая-память-malloc-calloc-realloc-free)
- [6. Zombie и Daemon процессы](#6-zombie-и-daemon-процессы)
- [7. Сигналы](#7-сигналы)
- [8. Многопоточность и синхронизация](#8-многопоточность-и-синхронизация)
- [9. IPC (межпроцессное взаимодействие)](#9-ipc-межпроцессное-взаимодействие)
- [10. IO Multiplexing](#10-io-multiplexing)

## 0. Введение

Программирование на языке C начинается не только с понимания синтаксиса, но и с осознания того, как работает компиляция.  
Перед тем как компилятор начнёт анализировать код, его обрабатывает **препроцессор** — специальный этап, отвечающий за подготовку исходного текста программы.

### Что такое препроцессор?

Препроцессор — это инструмент, который выполняет обработку кода *до* компиляции.  
Он занимается:

- подключением файлов (`#include`)
- созданием текстовых подстановок (`#define`)
- условной компиляцией (`#ifdef`, `#ifndef`, `#if`)
- разворачиванием макросов
- удалением комментариев

Работа препроцессора не знает о типах данных — он просто преобразует текст программы.

### Что такое макрос?

**Макрос** — это правило, по которому препроцессор выполняет текстовую замену в коде.  
Можно считать макросы "шаблонами" или "ярлыками", которые подставляются в программу до компиляции.

Основные виды макросов:

- **Макрос-константа**  
  ```c
  #define PI 3.14
  ```
- **Условные макросы для включения/исключения кода**
  ```c
  #ifdef DEBUG
  printf("Debug mode\n");
  #endif
  ```

Макросы удобны, но могут быть опасны из-за отсутствия проверки типов и возможных ошибок подстановки, поэтому в современном коде их используют осторожно.

### Как код на С превращается в программу
Когда ты пишешь `program.c`, он не превращается в бинарник сразу.
Компилятор проходит 4 основных этапа:
1) **Препроцессор**
   Выполняется первым.
   -  подставляет #include
   -  разворачивает #define
   -  обрабатывает #ifdef, #if, #pragma
   -  удаляет комментарии
   Команда:
   ```c
   gcc -E program.c -o program.i
   ```
   Результат: program.i — обычный текстовый файл с полностью развёрнутым кодом.
   
3) **Компилятор**
   Берёт результат препроцессора и превращает C-код в assembly (ассемблерный код).
Он:
- анализирует синтаксис
- проверяет типы
- оптимизирует код
- генерирует ассемблер
Команда:
```c
gcc -S program.i -o program.s
```
Результат: program.s — ассемблерный код.
4) **Ассемблер**

Превращает ассемблерный код в машинный код, но ещё не полный исполняемый файл.

Команда:
```c
gcc -c program.s -o program.o
```
Результат: program.o — объектный файл (часть будущей программы).
Это бинарный файл, который содержат:
- машинный код
- таблицы символов
- незаполненные ссылки на функции (например, printf)

5) **Компоновщик**
Собирает все объектные файлы (*.o) + стандартные библиотеки (например, libc)
в единый исполняемый файл.

Линкер:
- связывает вызовы функций (например, где лежит printf)
- объединяет все объектные файлы
- собирает таблицы адресов и секции памяти
- проверяет повторные определения символов

Команда:
```c
gcc program.o -o program
```
Результат: готовый бинарник → program

6) Выполнение
   Операционная система:
   - Загружает бинарник в память
   - Создаёт процесс
   - Запускает main()
   - Управляет стеком, кучей, сегментами памяти

---

## 1. Препроцессор: `#include` и `#define`

`#include` вставляет содержимое другого файла **до компиляции**.

### Два способа:

#### `<file>` — ищет файл в системных директориях
```c
#include <stdio.h> // стандартная библиотека ввода/вывода
```

#### `"file"` — ищет сначала в текущей директории, потом в системной
```c
#include "myheader.h"
```

---

### `#define`

Создаёт макрос (текстовую подстановку).

#### Пример константы
```c
#define PI 3.14159
```

#### Пример функции-макроса
```c
#define SQUARE(x) ((x) * (x))
```

#### Разница с `const`
- `#define` — чистая текстовая подстановка, нет проверки типов.
- `const` — настоящая переменная:

```c
const double pi = 3.14159;
```


| Что                      | `#define`                               | `const`              |
|--------------------------|----------------------------------------|---------------------|
| Обрабатывается           | препроцессором                          | компилятором        |
| Тип                      | отсутствует (текстовая подстановка)     | есть строгий тип    |
| Видимость в отладке      | нет                                     | есть                |
| Для чего используется    | макросы, константы, условная компиляция| неизменяемые переменные |
| Проверка типов           | нет                                     | есть                |
| Память                   | не занимает (подстановка в код)         | может занимать (если переменная) |
| Можно использовать в...  | `#if`, `#ifdef`, `#ifndef`             | нельзя              |
| Область применения       | любой фрагмент текста                   | переменные или параметры |
| Модифицирует поведение   | да (замена текста)                      | нет — обычная переменная |
| Лучше всего подходит для | макросов, флагов, встроенных выражений | констант со строгой типизацией |


---

Часто импортируемые библиотеки в заданиях:
```c
#include <stdio.h>      // стандартный ввод/вывод: printf, scanf, fprintf, fopen
#include <stdlib.h>     // общие утилиты: malloc, calloc, realloc, free, exit, atoi
#include <string.h>     // работа со строками: strcpy, strcat, strlen, strcmp, memset
#include <unistd.h>     // POSIX API: fork, exec, pipe, read, write, close, sleep, getpid
#include <errno.h>      // для работы с кодами ошибок errno
#include <fcntl.h>      // управление файлами и дескрипторами: open, O_RDONLY, O_CREAT
#include <sys/types.h>  // основные типы данных: pid_t, size_t, key_t
#include <sys/stat.h>   // структура stat, режимы файлов, mkdir
#include <time.h>       // работа с временем: time, clock, nanosleep
#include <signal.h>     // работа с сигналами: sigaction, signal, raise, kill
#include <pthread.h>    // POSIX потоки: pthread_create, pthread_mutex, pthread_cond, pthread_barrier
#include <semaphore.h>  // семафоры: sem_init, sem_wait, sem_post, sem_destroy
#include <stdatomic.h>  // атомарные операции: atomic_int, atomic_fetch_add
#include <sys/wait.h>   // работа с процессами: wait, waitpid, WNOHANG
#include <sys/mman.h>   // shared memory: mmap, munmap, PROT_READ/WRITE, MAP_SHARED
#include <sys/ipc.h>    // IPC ключи: ftok, IPC_CREAT
#include <sys/msg.h>    // очереди сообщений: msgget, msgsnd, msgrcv
#include <sys/sem.h>    // системные семафоры (SysV): semget, semop
#include <sys/shm.h>    // системная shared memory: shmget, shmat, shmdt
#include <sys/socket.h> // сокеты: socket, bind, listen, accept, connect
#include <netinet/in.h> // структуры для работы с IP (sockaddr_in)
#include <arpa/inet.h>  // преобразование IP адресов: inet_addr, inet_ntoa
#include <sys/select.h> // I/O Multiplexing: select, FD_SET, FD_ZERO
#include <sys/epoll.h>  // I/O Multiplexing (Linux): epoll_create, epoll_ctl, epoll_wait
#include <sys/syscall.h> // syscall для futex и других системных вызовов
```

---

## 2. Типы данных и модификаторы

### Базовые типы C

```c
int a = 10;
unsigned int b = 20;
long c = 1000000;
float f = 3.14;
double d = 2.71828;
char ch = 'A';
extern volatile int g_counter; //в хедере чаще всего
```

- `const` — переменная только для чтения.
- `volatile` — значение может меняться извне, компилятор не оптимизирует доступ.
- `unsigned char` — это целочисленный тип размера 1 байт, который может хранить только положительные значения.
- `extern` — это указание компилятору, что переменная или функция объявляется, но определяется в другом месте (в другом файле или позже в коде)

## `typedef`

`typedef` используется для создания нового имени (псевдонима) для существующего типа.  
Это не новый тип — просто удобное альтернативное название, улучшающее читаемость кода.

### Примеры использования

#### 1. Псевдоним для стандартного типа
```c
typedef unsigned long ulong;
```
Теперь можно писать так:
```c
ulong x = 100;
```

#### 2. Упрощение записи указателей
```c
typedef int* int_ptr;

int_ptr p;   // вместо: int *p;
```

#### 3. Типы для структур
Без typedef
```c
struct Point {
    int x, y;
};

struct Point p;  // нужно писать "struct" каждый раз
```
С typedef
```c
typedef struct {
    int x, y;
} Point;

Point p;    // короче и удобнее
```

---

## 3. Указатели и разыменование

- `*` — разыменование  
- `&` — получение адреса


```c
int x = 5;
int *p = &x;     // указатель на x
printf("%d\n", *p); // разыменование, вывод 5

int arr[3] = {1,2,3};
int *ptr = arr;  // имя массива — указатель на первый элемент
```

---

## 4. Структуры и указатели на них

```c
struct Point {
    int x, y;
};

struct Point p1 = {10, 20};
struct Point *pp = &p1;

printf("%d\n", pp->x); // 10
```
-> разыменовывает указатель на структуру и обращается к её полю в одном шаге.

---

## 5. Динамическая память: `malloc`, `calloc`, `realloc`, `free`

### 5.1 `malloc`
Выделяет непрерывный блок памяти.

```c
int *arr = (int*)malloc(5 * sizeof(int));
```

Память **не инициализирована**.

### 5.2 `calloc`
Выделяет и **обнуляет** память.

```c
int *arr = (int*)calloc(5, sizeof(int));
```

### 5.3 `realloc`
Меняет размер существующего блока.

```c
arr = (int*)realloc(arr, 10 * sizeof(int));
```

### 5.4 `free`
Освобождает выделенную память.

```c
free(arr);
arr = NULL;
```

---

### Различия между `malloc`, `calloc`, `realloc`

| Функция | Инициализация | Аргументы | Назначение |
|--------|---------------|-----------|------------|
| malloc | нет | размер в байтах | выделяет память |
| calloc | да (0) | количество, размер одного | выделяет и обнуляет |
| realloc | сохраняет старые данные | указатель, новый размер | меняет размер блока |

---

## 6. Zombie и Daemon процессы
### 6.1 Создание процессов

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process\n");
        exit(0);
    } else {
        wait(NULL); // ждём дочерний процесс
        printf("Parent process\n");
    }
}
```
---

### 6.2 Zombie

Процесс завершён, но родитель не вызвал `wait()`, то есть все еще остается в системе, но в то же время не занимают CPU.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child done\n");
        exit(0);
    } else {
        sleep(10); // дочерний — zombie
    }
}
```

**Как избежать:** вызывать `wait()` / `waitpid()`.

---

### 6.3 Daemon

Фоновый процесс, не привязанный к терминалу и не имеющий родителя4.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid > 0) exit(0);
    setsid();
    while(1) {
        sleep(1);
    }
}
```
---

## 7. Сигналы
Сигнал — это уведомление ядра процессу.
Сигнал может:
- SIGKILL: прервать программу,
- SIGPIPE: завершить программу,
- SIGCHLD: ничего не сделать (если он игнорируется),
- SIGSTOP: остановить выполнения,
- SIGCONT: возобновить выполнение.
```c
#include <signal.h>
#include <stdio.h>

void handler(int sig) {          // Функция-обработчик сигнала
    printf("Caught %d\n", sig); // Выводим номер сигнала, который пришёл
}

int main() {
    struct sigaction sa;          // Создаём структуру, описывающую поведение сигнала

    sa.sa_handler = handler;      // Назначаем обработчик сигнала (нашу функцию handler)
    sigemptyset(&sa.sa_mask);     // Инициализируем маску сигналов — пока выполняется handler, другие сигналы не блокируются
    sa.sa_flags = 0;              // Флаги поведения сигнала (0 — базовое поведение без дополнительных опций)

    sigaction(SIGINT, &sa, NULL); // Привязываем структуру sa к сигналу SIGINT (Ctrl+C)
                                   // NULL — старое действие сигнала не сохраняем

    while(1);                     
}

```

---

## 8. Многопоточность и синхронизация

### 8.1 Создание потока
```c
#include <pthread.h>
#include <stdio.h>

void* thread_func(void* arg) {
    printf("Hello from thread %d\n", *(int*)arg);
    return NULL;
}

int main() {
    pthread_t t;
    int id = 1;
    pthread_create(&t, NULL, thread_func, &id);
    pthread_join(t, NULL);
}
```

### 8.2 Mutex
Mutex — это механизм, который позволяет только одному потоку одновременно работать с ресурсом, предотвращая гонку данных.
```c
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);

pthread_mutex_lock(&lock);
// критическая секция
pthread_mutex_unlock(&lock);
```

### 8.3 Semaphore
Semaphore — это счётчик, который ограничивает одновременный доступ потоков или процессов к ресурсу
```c
#include <semaphore.h>
sem_t sem;
sem_init(&sem, 0, 3); // 3 ресурса

sem_wait(&sem); // захватываем
sem_post(&sem); // освобождаем

```

### 8.4 Condition Variable
Condition variable — это механизм, который позволяет потоку ждать определённого события и синхронизироваться с другими потоками через сигнал.
```c
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&mutex);
pthread_cond_wait(&cond, &mutex); // ждём события
pthread_mutex_unlock(&mutex);

pthread_cond_signal(&cond); // сигнал для пробуждения

```

### 8.5 Barrier
Barrier — это точка синхронизации, где несколько потоков ждут друг друга, прежде чем все смогут продолжить выполнение.
```c
pthread_barrier_t barrier;
pthread_barrier_init(&barrier, NULL, 3); // ждём 3 потока
pthread_barrier_wait(&barrier); // каждый поток ждёт остальных
```

### 8.6 Atomic operations
Atomic operation — это операция над переменной, которая выполняется полностью без прерываний, гарантируя корректный доступ в многопоточном окружении.
```c
#include <stdatomic.h>
atomic_int a = 0;
atomic_fetch_add(&a, 1);
```

### 8.7 Таблица
| Механизм             | Основная задача                  | Ограничения / Состояние             | Особенности использования |
|----------------------|---------------------------------|------------------------------------|--------------------------|
| Mutex                | Взаимное исключение, защита критической секции | Только один поток за раз           | Захватывает ресурс, другие ждут; подходит для защиты общих данных |
| Semaphore            | Ограничение количества потоков/ресурсов       | Счётчик ≥ 0                        | Позволяет N потокам одновременно работать с ресурсом; бинарный или счётный |
| Condition Variable   | Ждать наступления события                      | Не хранит состояния                | Используется с mutex; поток ждёт события, освобождая mutex пока ждёт |
| Barrier              | Синхронизация всех потоков на точке            | Ждёт указанное количество потоков  | Все потоки останавливаются на барьере, пока все не достигнут; потом продолжают работу |
| Atomic Operations    | Безопасная работа с простыми переменными      | Неразрывные операции               | Выполняются полностью без прерывания; подходят для lock-free счётчиков и флагов |

---

## 9. IPC (межпроцессное взаимодействие)
IPC — это механизм, с помощью которого два или более процесса могут обмениваться данными или сигналами.
В С/Unix-подобных системах есть несколько стандартных способов:

### 9.1 Pipes
Pipe — механизм передачи данных в виде потока байт между двумя связанными процессами (обычно родитель и потомок), поддерживает однонаправленное общение.

```c
#include <unistd.h>
int main() {
    int fd[2]; // fd[0] - чтение, fd[1] - запись
    pipe(fd);
    if (fork() == 0) {
        // Дочерний процесс - читает
        close(fd[1]);
        char buf[100];
        read(fd[0], buf, sizeof(buf));
        printf("Child received: %s\n", buf);
    } else {
        // Родительский процесс - пишет
        close(fd[0]);
        write(fd[1], "Hello from parent", 17);
    }
    return 0;
}
```
Особенности:
- Только родитель → ребёнок (однонаправленно).
- Pipe живёт только пока процессы существуют.
- Данные — поток байт.

---

### 9.2 Named Pipes (FIFOs)
Fifo — однонаправленный канал передачи данных между процессами, имеющий имя в файловой системе; позволяет обмениваться данными между процессами, которые не находятся в прямой родственной связи.

```c
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
int main() {
    const char *fifo_name = "/tmp/my_fifo";
    mkfifo(fifo_name, 0666);
    int fd = open(fifo_name, O_WRONLY);
    write(fd, "Hello FIFO", 10);
    close(fd);
    return 0;
}
```
Особенности:
- Может существовать между любыми процессами.
- Однонаправленный.
- Нужно удалять через unlink(fifo_name).

---

### 9.3 Message Queues (POSIX)
Message Queue — структура данных, предоставляемая ОС, для обмена дискретными сообщениями между процессами; поддерживает приоритет сообщений и позволяет работать с несколькими отправителями и получателями одновременно.

```c
#include <mqueue.h>
int main() {
    mqd_t mq;
    struct mq_attr attr = {0, 10, 256, 0}; // max 10 msg, 256 bytes each
    mq = mq_open("/myqueue", O_CREAT | O_WRONLY, 0644, &attr);
    mq_send(mq, "Hello MQ", 8, 0);
    mq_close(mq);
    return 0;
}
```
Особенности:
- Позволяет передавать сообщения как объекты, а не поток байт.
- Сообщения могут иметь приоритет.
- Нужно удалять через mq_unlink("/myqueue").

---

### 9.4 Shared Memory

Shared Memory — область памяти, доступная сразу нескольким процессам; обеспечивает высокую скорость обмена данными, но требует внешних средств синхронизации (например, семафоров или мьютексов) для предотвращения состояния гонки.

```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
int main() {
    const char *name = "/my_shm";
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    ftruncate(fd, 4096);
    char *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    strcpy(ptr, "Hello Shared Memory");
    munmap(ptr, 4096);
    close(fd);
    shm_unlink(name);
    return 0;
}
```

Особенности:
- Очень быстро.
- Требуется синхронизация, иначе данные могут портиться (например, с sem_t)

---

### 9.5 Semaphores

Semaphore — объект синхронизации, используемый для координации доступа нескольких процессов к общему ресурсу; может быть бинарным (mutex) или счётным. Не используется для передачи данных.

```c
#include <semaphore.h>
#include <fcntl.h>
int main() {
    sem_t *sem = sem_open("/mysem", O_CREAT, 0644, 1);
    sem_wait(sem);   // захват
    // критическая секция
    sem_post(sem);   // освобождение
    sem_close(sem);
    sem_unlink("/mysem");
    return 0;
}
```

Особенности:
- Только для синхронизации, данные не передаются.
- Часто используют вместе с shared memory.

---

### 9.6 Signals
Signal — асинхронные уведомления, отправляемые процессам для информирования о событиях, таких как завершение процесса, ошибки, таймеры или пользовательские события; сигналы передают только событие, а не данные.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
void handler(int sig) {
    printf("Received signal %d\n", sig);
}
int main() {
    signal(SIGUSR1, handler);
    printf("PID: %d\n", getpid());
    pause(); // ждем сигнала
    return 0;
}
```

Особенности:
- Асинхронно.
- Можно передавать только сигнал (не данные).

---

### 9.7 Unix Domain Sockets
Unix Domain Socket — механизм обмена данными между процессами на одном компьютере, обеспечивающий двунаправленную передачу байтов и возможность потоковой или сообщенийной коммуникации; по интерфейсу аналогичен TCP-сокетам, но работает локально.

```c
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, "/tmp/mysocket");
    bind(sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(sock, 5);
    int client = accept(sock, NULL, NULL);
    char buf[100];
    read(client, buf, sizeof(buf));
    printf("Received: %s\n", buf);
    close(client);
    close(sock);
    unlink("/tmp/mysocket");
    return 0;
}
```

Особенности:
- Можно использовать для межпроцессного и сетевого взаимодействия.
- Двунаправленные, универсальные.
- Более сложные, чем pipe/FIFO.

--- 

### 9.8 Общие рекомендации
- Для маленьких потоков байт → `pipe()` или `FIFO`.
- Для структурированных сообщений → `Message Queue`.
- Для больших объёмов данных и скорости → `Shared Memory + Semaphore`.
- Для универсальности и сетей → `Unix Domain Sockets`.
- Для уведомлений → `Signals`.

### 9.9 Сравнительная таблица
| Механизм IPC                  | Кратко                            | Плюсы                           | Минусы                                      |
|--------------------------------|----------------------------------|---------------------------------|--------------------------------------------|
| Pipes (именованные и неимен.)  | Поток байт между процессами       | Простой, потоковый              | Только однонаправленный (неименованные)   |
| FIFOs (Named Pipes)            | Pipe с именем в файловой системе | Межпроцессный, можно открывать в разное время | Однонаправленный                        |
| Message Queues                 | Очередь сообщений с приоритетом  | Двунаправленный, поддержка приоритета | Сложнее, ограничение на размер сообщений |
| Shared Memory                  | Общая память для процессов       | Очень быстро, можно передавать много данных | Требуется синхронизация (mutex/semaphore) |
| Semaphores                     | Счётчики для синхронизации       | Надёжная синхронизация          | Не передаёт данные                         |
| Signals                        | Асинхронные уведомления          | Лёгкие, быстрые                 | Только уведомление, нет данных             |
| Sockets (Unix Domain / TCP)    | Общение через сокеты             | Универсально, можно по сети     | Сложнее, накладные расходы                 |

---

## 10. I/O Multiplexing

Позволяет работать с несколькими файловыми дескрипторами.

Используемые функции:

```
select()
poll()
epoll()
```
