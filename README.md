# C / Linux: Шпаргалка
## Оглавление
- [Введение](#введение)
  - [Что такое препроцессор?](#что-такое-препроцессор)
  - [Что такое макрос?](#что-такое-макрос)
  - [Как код на C превращается в программу](#как-код-на-с-превращается-в-программу)
- [1. Препроцессор: `#include` и `#define`](#1-препроцессор-include-и-define)
  - [`#include`](#include)
  - [`#define`](#define)
- [2. Типы данных и модификаторы](#2-типы-данных-и-модификаторы)
  - [`typedef`](#typedef)
- [3. Указатели и разыменование](#3-указатели-и-разыменование)
- [4. Структуры и указатели на них](#4-структуры-и-указатели-на-них)
- [5. Динамическая память](#5-динамическая-память-malloc-calloc-realloc-free)
  - [Что такое malloc?](#5.1-malloc)
- [6. Zombie и Daemon процессы](#6-zombie-и-daemon-процессы)
- [7. Сигналы](#7-сигналы)
- [8. Многопоточность и синхронизация](#8-многопоточность-и-синхронизация)
- [9. IPC (межпроцессное взаимодействие)](#9-ipc-межпроцессное-взаимодействие)
- [10. IO Multiplexing](#10-io-multiplexing)
- [11. Статические и динамические библиотеки](#11-cтатические-и-динамические-библиотеки)
  
## 0. Введение

Программирование на языке C начинается не только с понимания синтаксиса, но и с осознания того, как работает компиляция.  
Перед тем как компилятор начнёт анализировать код, его обрабатывает **препроцессор** — специальный этап, отвечающий за подготовку исходного текста программы.

### Что такое препроцессор?

Препроцессор — это инструмент, который выполняет обработку кода *до* компиляции.  
Он занимается:

- подключением файлов (`#include`)
- созданием текстовых подстановок (`#define`)
- условной компиляцией (`#ifdef`, `#ifndef`, `#if`)
- разворачиванием макросов
- удалением комментариев

Работа препроцессора не знает о типах данных — он просто преобразует текст программы.

### Что такое макрос?

**Макрос** — это правило, по которому препроцессор выполняет текстовую замену в коде.  
Можно считать макросы "шаблонами" или "ярлыками", которые подставляются в программу до компиляции.

Основные виды макросов:

- **Макрос-константа**  
  ```c
  #define PI 3.14
  ```
- **Условные макросы для включения/исключения кода**
  ```c
  #ifdef DEBUG
  printf("Debug mode\n");
  #endif
  ```

Макросы удобны, но могут быть опасны из-за отсутствия проверки типов и возможных ошибок подстановки, поэтому в современном коде их используют осторожно.

### Как код на С превращается в программу
Когда ты пишешь `program.c`, он не превращается в бинарник сразу.
Компилятор проходит 4 основных этапа:

#### 0.1 **Препроцессор**
   
Выполняется первым.
Он:
   -  подставляет #include
   -  разворачивает #define
   -  обрабатывает #ifdef, #if, #pragma
   -  удаляет комментарии
   Команда:
   ```c
   gcc -E program.c -o program.i
   ```
   Результат: program.i — обычный текстовый файл с полностью развёрнутым кодом.
   
#### 0.2 **Компилятор**
   
Берёт результат препроцессора и превращает C-код в assembly (ассемблерный код).
Компилятор:
- анализирует синтаксис
- проверяет типы
- оптимизирует код
- генерирует ассемблер
Команда:
```c
gcc -S program.i -o program.s
```
Результат: program.s — ассемблерный код.

#### 0.3 **Ассемблер**

Превращает ассемблерный код в машинный код, но ещё не полный исполняемый файл.

Команда:
```c
gcc -c program.s -o program.o
```
Результат: program.o — объектный файл (часть будущей программы).
Это бинарный файл, который содержат:
- машинный код
- таблицы символов
- незаполненные ссылки на функции (например, `printf`)

#### 0.3.5 **Дополнительно: создание других объектных файлов**

Если проект большой:
- компилятор генерирует много `.o` файлов
- некоторые из них сгруппированы в `.a` (static libraries)
- или `.so` (shared libraries)
  
#### 0.4 **Линковщик**

Собирает все объектные файлы (*.o) + стандартные библиотеки (например, libc)
в единый исполняемый файл.

Линкер:
- связывает вызовы функций (например, где лежит printf)
- объединяет все объектные файлы
- собирает таблицы адресов и секции памяти
- проверяет повторные определения символов

Команда:
```c
gcc program.o -o program
```
Результат: готовый бинарник → program

#### 0.4.5 Загрузчик

Когда ты вызываешь программу:
```c
./program
```

Срабатывает динамический загрузчик, который:
- мапит бинарник в память
- мапит libc.so, libpthread.so, и др.
- фиксирует PLT/GOT таблицы
- подготавливает стек (!)
- вызывает конструкторы (.init_array)
- вызывает main()


#### 0.5 Выполнение
   Операционная система:
   - Создаёт процесс
   - Выделяет память
   - настраивает argc/argv
   - подготавливает окружение (environment variables)
   - передаёт управление загрузчику
   - Загрузчик вызывает main()

#### 0.6 Полный путь, как C-код превращается в программу

```text
file.c
  ↓ (Препроцессор — разворачивает include/define)
file.i
  ↓ (Компилятор — анализирует, оптимизирует, создаёт assembly)
file.s
  ↓ (Ассемблер — превращает в машинный код)
file.o
  ↓ (Линковка — объединяет объектные файлы, подставляет адреса)
program (ELF)
  ↓ (Динамический загрузчик — подгружает библиотеки, готовит окружение)
main()
```

---

## 1. Препроцессор: `#include` и `#define`

### `#include` 
Вставляет содержимое другого файла **до компиляции**.

### Два способа:

#### `<file>` — ищет файл в системных директориях
```c
#include <stdio.h> // стандартная библиотека ввода/вывода
```

#### `"file"` — ищет сначала в текущей директории, потом в системной
```c
#include "myheader.h"
```

---

### `#define`

Создаёт макрос (текстовую подстановку).

#### Пример константы
```c
#define PI 3.14159
```

#### Пример функции-макроса
```c
#define SQUARE(x) ((x) * (x))
```

#### Разница с `const`
- `#define` — чистая текстовая подстановка, нет проверки типов.
- `const` — настоящая переменная:

```c
const double pi = 3.14159;
```


| Что                      | `#define`                               | `const`              |
|--------------------------|----------------------------------------|---------------------|
| Обрабатывается           | препроцессором                          | компилятором        |
| Тип                      | отсутствует (текстовая подстановка)     | есть строгий тип    |
| Видимость в отладке      | нет                                     | есть                |
| Для чего используется    | макросы, константы, условная компиляция| неизменяемые переменные |
| Проверка типов           | нет                                     | есть                |
| Память                   | не занимает (подстановка в код)         | может занимать (если переменная) |
| Можно использовать в...  | `#if`, `#ifdef`, `#ifndef`             | нельзя              |
| Область применения       | любой фрагмент текста                   | переменные или параметры |
| Модифицирует поведение   | да (замена текста)                      | нет — обычная переменная |
| Лучше всего подходит для | макросов, флагов, встроенных выражений | констант со строгой типизацией |


---

Часто импортируемые библиотеки в заданиях:
```c
#include <stdio.h>      // стандартный ввод/вывод: printf, scanf, fprintf, fopen
#include <stdlib.h>     // общие утилиты: malloc, calloc, realloc, free, exit, atoi
#include <string.h>     // работа со строками: strcpy, strcat, strlen, strcmp, memset
#include <unistd.h>     // POSIX API: fork, exec, pipe, read, write, close, sleep, getpid
#include <errno.h>      // для работы с кодами ошибок errno
#include <fcntl.h>      // управление файлами и дескрипторами: open, O_RDONLY, O_CREAT
#include <sys/types.h>  // основные типы данных: pid_t, size_t, key_t
#include <sys/stat.h>   // структура stat, режимы файлов, mkdir
#include <time.h>       // работа с временем: time, clock, nanosleep
#include <signal.h>     // работа с сигналами: sigaction, signal, raise, kill
#include <pthread.h>    // POSIX потоки: pthread_create, pthread_mutex, pthread_cond, pthread_barrier
#include <semaphore.h>  // семафоры: sem_init, sem_wait, sem_post, sem_destroy
#include <stdatomic.h>  // атомарные операции: atomic_int, atomic_fetch_add
#include <sys/wait.h>   // работа с процессами: wait, waitpid, WNOHANG
#include <sys/mman.h>   // shared memory: mmap, munmap, PROT_READ/WRITE, MAP_SHARED
#include <sys/ipc.h>    // IPC ключи: ftok, IPC_CREAT
#include <sys/msg.h>    // очереди сообщений: msgget, msgsnd, msgrcv
#include <sys/sem.h>    // системные семафоры (SysV): semget, semop
#include <sys/shm.h>    // системная shared memory: shmget, shmat, shmdt
#include <sys/socket.h> // сокеты: socket, bind, listen, accept, connect
#include <netinet/in.h> // структуры для работы с IP (sockaddr_in)
#include <arpa/inet.h>  // преобразование IP адресов: inet_addr, inet_ntoa
#include <sys/select.h> // I/O Multiplexing: select, FD_SET, FD_ZERO
#include <sys/epoll.h>  // I/O Multiplexing (Linux): epoll_create, epoll_ctl, epoll_wait
#include <sys/syscall.h> // syscall для futex и других системных вызовов
```

---

## 2. Типы данных и модификаторы

### Базовые типы C

```c
int a = 10;
unsigned int b = 20;
long c = 1000000;
float f = 3.14;
double d = 2.71828;
char ch = 'A';
extern volatile int g_counter; //в хедере чаще всего
```

- `const` — переменная только для чтения.
- `volatile` — значение может меняться извне, компилятор не оптимизирует доступ.
- `unsigned char` — это целочисленный тип размера 1 байт, который может хранить только положительные значения.
- `extern` — это указание компилятору, что переменная или функция объявляется, но определяется в другом месте (в другом файле или позже в коде)

## `typedef`

`typedef` используется для создания нового имени (псевдонима) для существующего типа.  
Это не новый тип — просто удобное альтернативное название, улучшающее читаемость кода.

### Примеры использования

#### 1. Псевдоним для стандартного типа
```c
typedef unsigned long ulong;
```
Теперь можно писать так:
```c
ulong x = 100;
```

#### 2. Упрощение записи указателей
```c
typedef int* int_ptr;

int_ptr p;   // вместо: int *p;
```

#### 3. Типы для структур
Без typedef
```c
struct Point {
    int x, y;
};

struct Point p;  // нужно писать "struct" каждый раз
```
С typedef
```c
typedef struct {
    int x, y;
} Point;

Point p;    // короче и удобнее
```

---

## 3. Указатели и разыменование

- `*` — разыменование  
- `&` — получение адреса


```c
int x = 5;
int *p = &x;     // указатель на x
printf("%d\n", *p); // разыменование, вывод 5

int arr[3] = {1,2,3};
int *ptr = arr;  // имя массива — указатель на первый элемент
```

---

## 4. Структуры и указатели на них

```c
struct Point {
    int x, y;
};

struct Point p1 = {10, 20};
struct Point *pp = &p1;

printf("%d\n", pp->x); // 10
```
-> разыменовывает указатель на структуру и обращается к её полю в одном шаге.

---

## 5. Динамическая память: `malloc`, `calloc`, `realloc`, `free`

### 5.1 `malloc`
Выделяет непрерывный блок памяти.

```c
int *arr = (int*)malloc(5 * sizeof(int));
```

Память **не инициализирована**.

### 5.2 `calloc`
Выделяет и **обнуляет** память.

```c
int *arr = (int*)calloc(5, sizeof(int));
```

### 5.3 `realloc`
Меняет размер существующего блока.

```c
arr = (int*)realloc(arr, 10 * sizeof(int));
```

### 5.4 `free`
Освобождает выделенную память.

```c
free(arr);
arr = NULL;
```

---

### Различия между `malloc`, `calloc`, `realloc`

| Функция | Инициализация | Аргументы | Назначение |
|--------|---------------|-----------|------------|
| malloc | нет | размер в байтах | выделяет память |
| calloc | да (0) | количество, размер одного | выделяет и обнуляет |
| realloc | сохраняет старые данные | указатель, новый размер | меняет размер блока |

---

## 6. Zombie и Daemon процессы
### 6.1 Создание процессов

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process\n");
        exit(0);
    } else {
        wait(NULL); // ждём дочерний процесс
        printf("Parent process\n");
    }
}
```
---

### 6.2 Zombie

Процесс завершён, но родитель не вызвал `wait()`, то есть все еще остается в системе, но в то же время не занимают CPU.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child done\n");
        exit(0);
    } else {
        sleep(10); // дочерний — zombie
    }
}
```

**Как избежать:** вызывать `wait()` / `waitpid()`.

---

### 6.3 Daemon

Фоновый процесс, не привязанный к терминалу и не имеющий родителя4.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid > 0) exit(0);
    setsid();
    while(1) {
        sleep(1);
    }
}
```
---

## 7. Сигналы
Сигнал — это уведомление ядра процессу.
Сигнал может:
- SIGKILL: прервать программу,
- SIGPIPE: завершить программу,
- SIGCHLD: ничего не сделать (если он игнорируется),
- SIGSTOP: остановить выполнения,
- SIGCONT: возобновить выполнение.
```c
#include <signal.h>
#include <stdio.h>

void handler(int sig) {          // Функция-обработчик сигнала
    printf("Caught %d\n", sig); // Выводим номер сигнала, который пришёл
}

int main() {
    struct sigaction sa;          // Создаём структуру, описывающую поведение сигнала

    sa.sa_handler = handler;      // Назначаем обработчик сигнала (нашу функцию handler)
    sigemptyset(&sa.sa_mask);     // Инициализируем маску сигналов — пока выполняется handler, другие сигналы не блокируются
    sa.sa_flags = 0;              // Флаги поведения сигнала (0 — базовое поведение без дополнительных опций)

    sigaction(SIGINT, &sa, NULL); // Привязываем структуру sa к сигналу SIGINT (Ctrl+C)
                                   // NULL — старое действие сигнала не сохраняем

    while(1);                     
}

```

---

## 8. Многопоточность и синхронизация

### 8.1 Создание потока
```c
#include <pthread.h>
#include <stdio.h>

void* thread_func(void* arg) {
    printf("Hello from thread %d\n", *(int*)arg);
    return NULL;
}

int main() {
    pthread_t t;
    int id = 1;
    pthread_create(&t, NULL, thread_func, &id);
    pthread_join(t, NULL);
}
```

### 8.2 Mutex
Mutex — это механизм, который позволяет только одному потоку одновременно работать с ресурсом, предотвращая гонку данных.
```c
pthread_mutex_t lock;
pthread_mutex_init(&lock, NULL);

pthread_mutex_lock(&lock);
// критическая секция
pthread_mutex_unlock(&lock);
```

### 8.3 Semaphore
Semaphore — это счётчик, который ограничивает одновременный доступ потоков или процессов к ресурсу

Имеет следующие cистемные вызовы:
- Неименнованые: `sem_init(sem_t *sem, int pshared, unsigned int value)`.(pshared = 0 → семафор используется между потоками одного процесса. pshared = 1 → семафор может использоваться между разными процессами, если хранится в общей памяти (shared memory).)
- Именованные: `sem_open("/mysem", ...)`
- `sem_wait(sem)` — ждёт, пока значение семафора больше 0, затем уменьшает его на 1.
- `sem_post(sem)` — увеличивает значение семафора на 1, пробуждая ожидающий процесс, если он есть.
- `sem_open(name, flags, mode, value)` — создаёт или открывает именованный семафор.
- `sem_close(sem)` — закрывает дескриптор семафора.
- `sem_trywait(sem)` — пробует уменьшить значение семафора на 1 без блокировки. (val > 0 → уменьшает и возвращает 0. val = 0 → сразу возвращает -1 с errno = EAGAIN.)
- `sem_getvalue(sem, int *sval)` — получает текущее значение семафора.
- `sem_destroy(sem)` — уничтожает неименованный семафор.
- `sem_unlink(name)` — удаляет именованный семафор из системы.

```c
#include <semaphore.h>
sem_t sem;
sem_init(&sem, 0, 3); // 3 ресурса

sem_wait(&sem); // захватываем
sem_post(&sem); // освобождаем

```

### 8.4 Condition Variable
Condition variable — это механизм, который позволяет потоку ждать определённого события и синхронизироваться с другими потоками через сигнал.
```c
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&mutex);
pthread_cond_wait(&cond, &mutex); // ждём события
pthread_mutex_unlock(&mutex);

pthread_cond_signal(&cond); // сигнал для пробуждения

```

### 8.5 Barrier
Barrier — это точка синхронизации, где несколько потоков ждут друг друга, прежде чем все смогут продолжить выполнение.
```c
pthread_barrier_t barrier;
pthread_barrier_init(&barrier, NULL, 3); // ждём 3 потока
pthread_barrier_wait(&barrier); // каждый поток ждёт остальных
```

### 8.6 Atomic operations
Atomic operation — это операция над переменной, которая выполняется полностью без прерываний, гарантируя корректный доступ в многопоточном окружении.
```c
#include <stdatomic.h>
atomic_int a = 0;
atomic_fetch_add(&a, 1);
```

### 8.7 Таблица
| Механизм             | Основная задача                  | Ограничения / Состояние             | Особенности использования |
|----------------------|---------------------------------|------------------------------------|--------------------------|
| Mutex                | Взаимное исключение, защита критической секции | Только один поток за раз           | Захватывает ресурс, другие ждут; подходит для защиты общих данных |
| Semaphore            | Ограничение количества потоков/ресурсов       | Счётчик ≥ 0                        | Позволяет N потокам одновременно работать с ресурсом; бинарный или счётный |
| Condition Variable   | Ждать наступления события                      | Не хранит состояния                | Используется с mutex; поток ждёт события, освобождая mutex пока ждёт |
| Barrier              | Синхронизация всех потоков на точке            | Ждёт указанное количество потоков  | Все потоки останавливаются на барьере, пока все не достигнут; потом продолжают работу |
| Atomic Operations    | Безопасная работа с простыми переменными      | Неразрывные операции               | Выполняются полностью без прерывания; подходят для lock-free счётчиков и флагов |

---

## 9. IPC (межпроцессное взаимодействие)
IPC — это механизм, с помощью которого два или более процесса могут обмениваться данными или сигналами.
В С/Unix-подобных системах есть несколько стандартных способов:

### 9.1 Pipes
Pipe — механизм передачи данных в виде потока байт между двумя связанными процессами (обычно родитель и потомок), поддерживает однонаправленное общение.

```c
#include <unistd.h>
int main() {
    int fd[2]; // fd[0] - чтение, fd[1] - запись
    pipe(fd);
    if (fork() == 0) {
        // Дочерний процесс - читает
        close(fd[1]);
        char buf[100];
        read(fd[0], buf, sizeof(buf));
        printf("Child received: %s\n", buf);
    } else {
        // Родительский процесс - пишет
        close(fd[0]);
        write(fd[1], "Hello from parent", 17);
    }
    return 0;
}
```
Особенности:
- Только родитель → ребёнок (однонаправленно).
- Pipe живёт только пока процессы существуют.
- Данные — поток байт.

---

### 9.2 Named Pipes (FIFOs)
Fifo — однонаправленный канал передачи данных между процессами, имеющий имя в файловой системе; позволяет обмениваться данными между процессами, которые не находятся в прямой родственной связи.

Систенмые вызовы:
- mkfifo — создать именованный pipe (FIFO)
```c
mkfifo("/tmp/my_fifo", 0666); //Любой процесс может открыть /tmp/my_fifo для чтения или записи
```

- open — открыть FIFO. Можно использовать O_RDONLY / O_WRONLY / O_RDWR
```c
int fd = open("/tmp/my_fifo", O_WRONLY);
```

- read / write — работа с pipe
```c
write(fd, buffer, size);
read(fd, buffer, size);
```

- close — закрыть дескриптор
```c
close(fd);
```
- unlink — удалить именованный pipe
```c
unlink("/tmp/my_fifo");
```

Код для примера:
```c
#include <sys/stat.h>   // mkfifo, S_IRUSR, S_IWUSR и др.
#include <fcntl.h>      // open, O_RDONLY, O_WRONLY и др.
#include <unistd.h>     // read, write, close
int main() {
    const char *fifo_name = "/tmp/my_fifo";  // Имя FIFO в файловой системе
    mkfifo(fifo_name, 0666); // Создаём именованный pipe (FIFO). 0666 — права доступа (чтение и запись для всех)
    int fd = open(fifo_name, O_WRONLY); // Открываем FIFO для записи. Блокируется, пока не откроется процесс на чтение
    write(fd, "Hello FIFO", 10); // Пишем данные в FIFO. Для чтения другой процесс должен открыть FIFO на чтение
    close(fd); // Закрываем дескриптор после записи
    unlink(fifo_name);
    return 0;
}

```
Особенности:
- Может существовать между любыми процессами.
- Однонаправленный.
- Нужно удалять через unlink(fifo_name).

---

### 9.3 Message Queues (POSIX)
Message Queue — структура данных, предоставляемая ОС, для обмена дискретными сообщениями между процессами; поддерживает приоритет сообщений и позволяет работать с несколькими отправителями и получателями одновременно.

```c
#include <mqueue.h>
int main() {
    mqd_t mq;
    struct mq_attr attr = {0, 10, 256, 0}; // max 10 msg, 256 bytes each
    mq = mq_open("/myqueue", O_CREAT | O_WRONLY, 0644, &attr);
    mq_send(mq, "Hello MQ", 8, 0);
    mq_close(mq);
    return 0;
}
```
Особенности:
- Позволяет передавать сообщения как объекты, а не поток байт.
- Сообщения могут иметь приоритет.
- Нужно удалять через mq_unlink("/myqueue").

---

### 9.4 Shared Memory

Shared Memory — область памяти, доступная сразу нескольким процессам; обеспечивает высокую скорость обмена данными, но требует внешних средств синхронизации (например, семафоров или мьютексов) для предотвращения состояния гонки.

Системные вызовы:
- shm_open — создать / открыть объект разделяемой памяти. Возвращает файловый дескриптор.
```c
int fd = shm_open("/name", O_CREAT | O_RDWR, 0666);
```
- ftruncate — задать фактический размер shared memory.
```c
ftruncate(fd, size);
```
- mmap — отобразить область памяти. Возвращает указатель, через который можно читать и писать.
```c
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_SHARED, fd, 0);
```
- Использовать память. Любые операции с памятью: структуры, массивы, произвольные данные.
```c
strcpy(ptr, "Hello");
```
- munmap — убрать отображение. Процесс больше не использует эту память (но объект всё ещё существует).
```c
munmap(ptr, size);
```
- close — закрыть файловый дескриптор. Закрывает FD от shm_open.
```c
close(fd);
```
- shm_unlink — удалить объект. После этого другие процессы не смогут его открыть.
```c
shm_unlink("/name");
```

Пример кода:
```c
#include <sys/mman.h>   // mmap, munmap, PROT_*, MAP_*
#include <fcntl.h>      // shm_open, O_CREAT, O_RDWR
#include <unistd.h>     // ftruncate, close
#include <string.h>     // strcpy
int main() {
    const char *name = "/my_shm";     // Имя объекта shared memory (обязательно начинается с '/')

    // Создаём или открываем сегмент разделяемой памяти.
    // O_CREAT — создать, если нет
    // O_RDWR  — открыть для чтения и записи
    // 0666    — права доступа
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);

    ftruncate(fd, 4096); // Устанавливаем размер сегмента (иначе будет 0 байт)

    // Отображаем объект в адресное пространство процесса:
    // NULL — система сама выберет адрес
    // 4096 — размер отображения
    // PROT_READ | PROT_WRITE — разрешено читать и писать
    // MAP_SHARED — изменения видны другим процессам
    // fd — файловый дескриптор shared memory
    // 0 — смещение
    char *ptr = mmap(NULL, 4096,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED,
                     fd, 0);
    strcpy(ptr, "Hello Shared Memory"); // Пишем строку прямо в shared memory
    munmap(ptr, 4096); // Удаляем отображение из памяти текущего процесса
    close(fd); // Закрываем файловый дескриптор
    shm_unlink(name); // Удаляем объект shared memory из системы
    return 0;
}

```

Особенности:
- Очень быстро.
- Требуется синхронизация, иначе данные могут портиться (например, с sem_t)

---

### 9.5 Semaphores

Semaphore — объект синхронизации, используемый для координации доступа нескольких процессов к общему ресурсу; может быть бинарным (mutex) или счётным. Не используется для передачи данных.

```c
#include <semaphore.h>
#include <fcntl.h>
int main() {
    sem_t *sem = sem_open("/mysem", O_CREAT, 0644, 1);
    sem_wait(sem);   // захват
    // критическая секция
    sem_post(sem);   // освобождение
    sem_close(sem);
    sem_unlink("/mysem");
    return 0;
}
```

Особенности:
- Только для синхронизации, данные не передаются.
- Часто используют вместе с shared memory.

---

### 9.6 Signals
Signal — асинхронные уведомления, отправляемые процессам для информирования о событиях, таких как завершение процесса, ошибки, таймеры или пользовательские события; сигналы передают только событие, а не данные.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
void handler(int sig) {
    printf("Received signal %d\n", sig);
}
int main() {
    signal(SIGUSR1, handler);
    printf("PID: %d\n", getpid());
    pause(); // ждем сигнала
    return 0;
}
```

Особенности:
- Асинхронно.
- Можно передавать только сигнал (не данные).

---

### 9.7 Unix Domain Sockets
Unix Domain Socket — механизм обмена данными между процессами на одном компьютере, обеспечивающий двунаправленную передачу байтов и возможность потоковой или сообщенийной коммуникации; по интерфейсу аналогичен TCP-сокетам, но работает локально.

```c
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdio.h>
int main() {
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, "/tmp/mysocket");
    bind(sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(sock, 5);
    int client = accept(sock, NULL, NULL);
    char buf[100];
    read(client, buf, sizeof(buf));
    printf("Received: %s\n", buf);
    close(client);
    close(sock);
    unlink("/tmp/mysocket");
    return 0;
}
```

Особенности:
- Можно использовать для межпроцессного и сетевого взаимодействия.
- Двунаправленные, универсальные.
- Более сложные, чем pipe/FIFO.

--- 

### 9.8 Общие рекомендации
- Для маленьких потоков байт → `pipe()` или `FIFO`.
- Для структурированных сообщений → `Message Queue`.
- Для больших объёмов данных и скорости → `Shared Memory + Semaphore`.
- Для универсальности и сетей → `Unix Domain Sockets`.
- Для уведомлений → `Signals`.

### 9.9 Сравнительная таблица
| Механизм IPC                  | Кратко                            | Плюсы                           | Минусы                                      |
|--------------------------------|----------------------------------|---------------------------------|--------------------------------------------|
| Pipes (именованные и неимен.)  | Поток байт между процессами       | Простой, потоковый              | Только однонаправленный (неименованные)   |
| FIFOs (Named Pipes)            | Pipe с именем в файловой системе | Межпроцессный, можно открывать в разное время | Однонаправленный                        |
| Message Queues                 | Очередь сообщений с приоритетом  | Двунаправленный, поддержка приоритета | Сложнее, ограничение на размер сообщений |
| Shared Memory                  | Общая память для процессов       | Очень быстро, можно передавать много данных | Требуется синхронизация (mutex/semaphore) |
| Semaphores                     | Счётчики для синхронизации       | Надёжная синхронизация          | Не передаёт данные                         |
| Signals                        | Асинхронные уведомления          | Лёгкие, быстрые                 | Только уведомление, нет данных             |
| Sockets (Unix Domain / TCP)    | Общение через сокеты             | Универсально, можно по сети     | Сложнее, накладные расходы                 |

---

## 10. I/O Multiplexing

I/O Multiplexing — это механизм, позволяющий одному процессу (или потоку) одновременно контролировать несколько файловых дескрипторов (сокетов, pipe, fifo, терминалов и т. д.) и эффективно ждать, пока хотя бы один из них станет готов к чтению/записи.

### 10.1 select()
- Старый и переносимый метод.
- Ограничение: FD_SETSIZE (~1024 дескриптора).
- Требует каждый раз заново заполнять fd_set.

Пример:
```c
#include <sys/select.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(0, &readfds); // stdin
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    int ret = select(1, &readfds, NULL, NULL, &timeout);
    if (ret > 0 && FD_ISSET(0, &readfds)) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
}
```

### 10.2 poll()
- Современная альтернатива select.
- Нет ограничения на количество FD.
- Структура pollfd для описания дескрипторов.
- O(n) по количеству дескрипторов.

Пример:
```c
#include <poll.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    struct pollfd fds[1];
    fds[0].fd = 0;           // stdin
    fds[0].events = POLLIN;

    int ret = poll(fds, 1, 5000); // 5000 ms
    if (ret > 0 && (fds[0].revents & POLLIN)) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
}
```
### 10.3 epoll (Linux only)
- Высокопроизводительный, событийно-ориентированный.
- Масштабируется на десятки тысяч дескрипторов.
- Используется в nginx, redis, node.js.

Пример:
```c
#include <sys/epoll.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    int epfd = epoll_create1(0);
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = 0; // stdin
    epoll_ctl(epfd, EPOLL_CTL_ADD, 0, &ev);

    struct epoll_event events[10];
    int n = epoll_wait(epfd, events, 10, 5000);
    if (n > 0) {
        char buf[100];
        read(0, buf, sizeof(buf));
        printf("You typed: %s\n", buf);
    } else {
        printf("Timeout or error\n");
    }
    close(epfd);
}
```

### 10.4 Сравнительная таблица
| Метод   | Ограничения            | Масштабируемость | Производительность | Особенности                                      |
|---------|-----------------------|-----------------|------------------|------------------------------------------------|
| select  | FD_SETSIZE (~1024)    | Низкая          | Средняя          | Требует каждый раз заполнять fd_set; совместим с Unix |
| poll    | Нет явных ограничений | Средняя         | Средняя          | Использует pollfd; O(n)                        |
| epoll   | Linux only            | Высокая         | Высокая          | Событийно-ориентированный; O(1) в большинстве случаев |

---

## 11. Статические и динамические библиотеки

Библиотеки — это набор объектных файлов (.o), которые содержат функции и переменные, готовые к использованию другими программами.
Главное отличие — способ подключения: на этапе компиляции (статическая) или на этапе выполнения (динамическая).

### 11.1 Статическая библиотека

Статическая библиотека (.a) — это архив объектных файлов, который встраивается в исполняемый файл на этапе линковки. После компиляции программа не требует файла библиотеки для запуска.

Создание статической библиотеки:
```bash
gcc -c foo.c -o foo.o     # компилируем объектный файл
ar rcs libfoo.a foo.o     # создаём статическую библиотеку
```

Использование в программе:
```c
#include "foo.h"

int main() {
    foo(); // функция из библиотеки
    return 0;
}
```

Компиляция с библиотекой:
```bash
gcc main.c -L. -lfoo -o program
```

Особенности:
- Все функции библиотеки включаются в бинарник.
- Программа полностью автономна.
- Бинарник может быть большим.
- Обновление библиотеки требует перекомпиляции программы.

### 11.2 Динамическая библиотека

Динамическая библиотека (`.so`) — это набор функций, подгружаемых во время выполнения программы.
Программа и библиотека связываются на этапе запуска или динамически через dlopen.

Создание динамической библиотеки:
```bash
gcc -fPIC -c foo.c -o foo.o   # PIC = position-independent code
gcc -shared foo.o -o libfoo.so
```

Использование в программе:
```c
#include "foo.h"
int main() {
    foo(); // функция из библиотеки
    return 0;
}
```

Компиляция с динамической библиотекой:
```bash
gcc main.c -L. -lfoo -o program
export LD_LIBRARY_PATH=.  # если библиотека не в стандартном пути
./program
```

Особенности:
- Функции загружаются из внешнего файла при запуске.
- Меньший размер бинарника.
- Можно обновлять библиотеку без перекомпиляции программы.
- Нужно, чтобы .so была доступна в LD_LIBRARY_PATH или в стандартных директориях /usr/lib, /usr/local/lib.

### 11.3 Сравнение
| Параметр                     | Статическая библиотека (.a)           | Динамическая библиотека (.so)                           |
|-------------------------------|------------------------------------|--------------------------------------------------------|
| Когда подключается            | При компиляции/линковке            | Во время выполнения                                     |
| Размер бинарника              | Больше                             | Меньше                                                 |
| Обновление функций            | Только перекомпиляция               | Достаточно заменить .so                                |
| Автономность программы        | Полная                              | Требуется .so                                         |
| Скорость вызова               | Быстрее (нет дополнительных таблиц)| Слегка медленнее (PLT/GOT)                             |
| Поддержка нескольких программ | Каждая копия содержит функции       | Библиотека общая, экономия памяти                      |

---
